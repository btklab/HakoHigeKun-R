<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>かんたんグラフ作成アプリ (HTML+Plotly)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        /* カスタムスタイル: サイドバーの幅とメインコンテンツの調整 */
        .sidebar {
            width: 320px;
            min-width: 320px;
        }
        .main-content {
            flex-grow: 1;
        }
        /* Plotlyの描画領域の高さ設定 - flexに任せる */
        #chart-container {
            min-height: 500px; /* 描画前の初期高さを確保 */
            flex-shrink: 0; /* グラフが高くてもコンテンツが縮まないように */
        }
        /* スクロールバーのスタイルを調整して見やすく */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #cbd5e1; /* gray-400 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-track {
            background-color: #f7f7f7; /* white smoke */
        }
        /* データテーブルのスクロール */
        .data-table-container {
            max-height: 400px;
            overflow-y: auto;
        }
        /* フッターを下に固定 */
        .footer {
            min-height: 40px;
            flex-shrink: 0;
        }
        /* 複数選択リストボックスの高さ調整 */
        .multi-select {
            min-height: 120px;
            max-height: 250px;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-gray-50 flex h-screen flex-col font-sans antialiased">
    
    <div class="flex flex-grow overflow-hidden">
        <!-- サイドバー -->
        <div class="sidebar bg-white p-6 flex flex-col shadow-lg overflow-y-auto flex-shrink-0">
            <h1 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">グラフ設定</h1>

            <!-- ファイルアップロード -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">データファイルを選択 (CSV/Excel)</label>
                <!-- accept属性でファイル選択肢を限定 -->
                <input type="file" id="fileInput" accept=".csv, .xlsx" class="block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-lg file:border-0
                    file:text-sm file:font-semibold
                    file:bg-indigo-50 file:text-indigo-600
                    hover:file:bg-indigo-100" />
            </div>

            <!-- グラフタイプ選択 -->
            <div class="mb-4">
                <label for="chartType" class="block text-sm font-medium text-gray-700 mb-2">グラフタイプ</label>
                <select id="chartType" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-lg shadow-sm">
                    <option value="none">-- 選択してください --</option>
                    <option value="histogram" selected>ヒストグラム</option>
                    <option value="box">箱ひげ図</option>
                    <option value="bar">棒グラフ</option>
                    <option value="line">折れ線グラフ</option>
                    <option value="scatter">散布図</option>
                    <option value="pareto">パレート図</option>
                    <option value="xrs_control">X-Rs 管理図</option>
                </select>
            </div>

            <!-- 選択カラム設定 (動的に表示/非表示を切り替え) -->
            <div id="column-selectors" class="space-y-4 flex-grow">
                
                <!-- X軸 / カテゴリ -->
                <div id="category-select-group">
                    <label for="categoryCol" class="block text-sm font-medium text-gray-700 mb-2">X軸 (カテゴリ/時系列)</label>
                    <select id="categoryCol" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-lg shadow-sm">
                        <option value="">-- データ列を選択 --</option>
                        <option value="__INDEX__">データポイントのIndex</option>
                    </select>
                </div>

                <!-- グループ列 (層別) -->
                <div id="group-select-group" class="hidden">
                    <label for="groupCol" class="block text-sm font-medium text-gray-700 mb-2">グループ列 (層別 - 任意)</label>
                    <select id="groupCol" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-lg shadow-sm">
                        <option value="">-- グループ化しない --</option>
                    </select>
                </div>

                <!-- Y軸 / データ値 (単一/複数選択) -->
                <div id="data-select-group" class="hidden">
                    <label for="dataCol" class="block text-sm font-medium text-gray-700 mb-2">Y軸 (数値 - 必須)</label>
                    
                    <!-- Y軸選択要素 (単一または複数としてJavaScriptで切り替わる) -->
                    <select id="dataCol" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-lg shadow-sm">
                        <!-- オプションはJSで挿入される -->
                    </select>

                    <!-- 折れ線グラフでのみ表示される複数選択切り替えチェックボックス -->
                    <div id="multi-select-toggle" class="mt-2 hidden">
                        <div class="flex items-center">
                            <input id="enableMultiSelect" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" onchange="toggleYAxisMultiSelect(this.checked)">
                            <label for="enableMultiSelect" class="ml-2 block text-sm text-gray-700">
                                複数のY軸データ系列を選択する
                            </label>
                        </div>
                        <p id="multi-select-tip" class="text-xs text-gray-500 mt-1 hidden">Ctrl/Commandキーを押しながら複数選択可能です。</p>
                    </div>

                </div>

                <!-- 実行ボタン -->
                <button id="generateChartBtn" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 ease-in-out disabled:opacity-50 mt-4" disabled>
                    グラフ作成
                </button>
                
                <!-- カスタムダウンロードボタン -->
                <button id="downloadChartBtn" class="w-full bg-green-500 text-white py-2 px-4 rounded-lg shadow-md hover:bg-green-600 transition duration-150 ease-in-out disabled:opacity-50 mt-2" disabled>
                    画像をダウンロード (PNG)
                </button>
            </div>

            <!-- エラーメッセージ -->
            <div id="message" class="mt-4 p-3 text-sm rounded-lg text-red-700 bg-red-100 hidden" role="alert"></div>

        </div>

        <!-- メインコンテンツ (グラフとデータプレビュー) -->
        <!-- overflow-y-autoを親に追加し、子の#chart-containerはflex-shrink:0で重なりを防止 -->
        <div class="main-content flex flex-col p-6 overflow-y-auto">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">グラフ表示エリア</h2>

            <!-- グラフコンテナ -->
            <div id="chart-container" class="bg-white p-4 rounded-lg shadow-xl mb-6 flex-shrink-0">
                <div id="plot">
                    <p class="text-gray-500 text-center py-20">左側のパネルからデータファイルをアップロードし、グラフ設定を行ってください。</p>
                </div>
            </div>

            <!-- データプレビュー -->
            <h2 class="text-xl font-semibold text-gray-800 mb-2">データプレビュー</h2>
            <div id="data-preview" class="data-table-container bg-white p-4 rounded-lg shadow-md border border-gray-200 mb-4">
                <p class="text-gray-500">データがロードされていません。</p>
            </div>
        </div>
    </div>
    
    <!-- フッターとクレジット -->
    <footer class="footer bg-gray-200 text-gray-600 text-xs p-2 text-center border-t border-gray-300">
        <p>
            Made with 
            <a href="https://plotly.com/javascript/" target="_blank" class="text-indigo-600 hover:text-indigo-800 font-semibold">Plotly.js</a>, 
            <a href="https://www.papaparse.com/" target="_blank" class="text-indigo-600 hover:text-indigo-800 font-semibold">PapaParse</a>, 
            <a href="https://sheetjs.com/" target="_blank" class="text-indigo-600 hover:text-indigo-800 font-semibold">SheetJS (xlsx)</a>, and
            <a href="https://tailwindcss.com/" target="_blank" class="text-indigo-600 hover:text-indigo-800 font-semibold">Tailwind CSS</a>.
        </p>
    </footer>


    <script>
        // グローバル変数
        let rawData = [];
        let headerNames = [];

        // グローバル定数
        const CHART_TYPE = {
            BAR: 'bar',
            LINE: 'line',
            SCATTER: 'scatter',
            HISTOGRAM: 'histogram',
            BOX: 'box',
            PARETO: 'pareto',
            XRS_CONTROL: 'xrs_control'
        };
        const INDEX_COLUMN_NAME = '__INDEX__'; // X軸でIndex値を使用するときの特殊な値

        // DOM要素
        const fileInput = document.getElementById('fileInput');
        const chartTypeSelect = document.getElementById('chartType');
        const categoryColSelect = document.getElementById('categoryCol'); // X軸
        const groupColSelect = document.getElementById('groupCol'); // グループ軸 (層別)
        const dataColSelect = document.getElementById('dataCol'); // Y軸 (単一/複数切り替え)
        const generateChartBtn = document.getElementById('generateChartBtn');
        const downloadChartBtn = document.getElementById('downloadChartBtn');
        const chartContainer = document.getElementById('plot');
        const messageDiv = document.getElementById('message');
        const dataPreviewDiv = document.getElementById('data-preview');
        const categorySelectGroup = document.getElementById('category-select-group');
        const groupSelectGroup = document.getElementById('group-select-group'); // 新しいグループ列のDOM
        const dataSelectGroup = document.getElementById('data-select-group');
        const multiSelectToggle = document.getElementById('multi-select-toggle');
        const enableMultiSelectCheckbox = document.getElementById('enableMultiSelect');
        const multiSelectTip = document.getElementById('multi-select-tip');

        // イベントリスナー設定
        fileInput.addEventListener('change', handleFileSelect);
        chartTypeSelect.addEventListener('change', updateUIBasedOnChartType);
        generateChartBtn.addEventListener('click', () => {
            // 選択されたY軸の値を取得（単一の場合は文字列、複数の場合は配列）
            const selectedYCols = getSelectedYAxisValues();
            // グループ列の値を取得
            const groupCol = groupColSelect.value;
            generateChart(chartTypeSelect.value, categoryColSelect.value, selectedYCols, groupCol);
        });
        categoryColSelect.addEventListener('change', checkInputs);
        groupColSelect.addEventListener('change', checkInputs); // グループ列の変更もチェック
        dataColSelect.addEventListener('change', checkInputs);
        downloadChartBtn.addEventListener('click', handleDownload);

        /**
         * 選択されたY軸の値を取得する。単一の場合は配列[string]、複数の場合は配列[string, string...]を返す。
         * @returns {Array<string>} 選択されたY軸の値の配列
         */
        function getSelectedYAxisValues() {
            if (dataColSelect.hasAttribute('multiple')) {
                return Array.from(dataColSelect.selectedOptions).map(option => option.value).filter(v => v);
            }
            // 単一選択の場合、値が存在すれば配列として返す
            const singleValue = dataColSelect.value;
            return singleValue ? [singleValue] : [];
        }

        /**
         * メッセージを表示/非表示する
         * @param {string} msg - 表示するメッセージ
         * @param {boolean} isError - エラーメッセージかどうか
         */
        function displayMessage(msg, isError = true) {
            messageDiv.textContent = msg;
            messageDiv.classList.remove('hidden');
            if (isError) {
                messageDiv.className = 'mt-4 p-3 text-sm rounded-lg text-red-700 bg-red-100';
            } else {
                messageDiv.className = 'mt-4 p-3 text-sm rounded-lg text-green-700 bg-green-100';
            }
        }

        /**
         * メッセージをクリアする
         */
        function clearMessage() {
            messageDiv.classList.add('hidden');
            messageDiv.textContent = '';
        }

        /**
         * ファイルを選択したときの処理
         */
        function handleFileSelect(event) {
            clearMessage();
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const fileName = file.name;
            const fileExtension = fileName.split('.').pop().toLowerCase();

            if (fileExtension === 'csv') {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => handleParsedData(results.data, results.meta.fields)
                });
            } else if (['xlsx', 'xls'].includes(fileExtension)) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        // ヘッダーを1行目として扱い、オブジェクト配列に変換
                        const json = XLSX.utils.sheet_to_json(worksheet); 
                        
                        if (json.length > 0) {
                            // ヘッダー名をキーから取得
                            const headers = Object.keys(json[0]).filter(h => h);
                            handleParsedData(json, headers);
                        } else {
                            displayMessage('Excelファイルにデータが見つかりませんでした。', true);
                        }
                    } catch (error) {
                        console.error("Excel解析エラー:", error);
                        displayMessage('Excelファイルの解析中にエラーが発生しました。', true);
                    }
                };
                reader.onerror = () => displayMessage('ファイルの読み込み中にエラーが発生しました。', true);
                reader.readAsArrayBuffer(file);
            } else {
                // ファイル選択制限をHTML側で設定しているため、基本的にはここには来ない
                displayMessage('サポートされていないファイル形式です。CSVまたはExcelファイルを選択してください。', true);
            }
        }

        /**
         * 解析されたデータを処理し、UIを更新する
         * @param {Array<Object>} data - 解析されたデータ行
         * @param {Array<string>} headers - ヘッダー名
         */
        function handleParsedData(data, headers) {
            if (data.length === 0 || headers.length === 0) {
                displayMessage('データが空またはヘッダー情報が見つかりません。', true);
                return;
            }

            rawData = data;
            headerNames = headers;
            
            updateColumnSelectors(headers);
            updateDataPreview(data, headers);
            updateUIBasedOnChartType();
            
            displayMessage(`データ ${headerNames.length}列 x ${rawData.length}行をロードしました。`, false);
        }

        /**
         * カラム選択ドロップダウンを更新する
         * @param {Array<string>} headers - ヘッダー名
         */
        function updateColumnSelectors(headers) {
            // X軸 (categoryColSelect)
            categoryColSelect.innerHTML = '<option value="">-- データ列を選択 --</option>';
            const indexOption = document.createElement('option');
            indexOption.value = INDEX_COLUMN_NAME;
            indexOption.textContent = 'データポイントのIndex';
            categoryColSelect.appendChild(indexOption);
            
            // Y軸 (dataColSelect) - 単一選択のプレースホルダ
            dataColSelect.innerHTML = '<option value="">-- データ列を選択 --</option>'; 

            // グループ軸 (groupColSelect)
            groupColSelect.innerHTML = '<option value="">-- グループ化しない --</option>';
            
            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                
                categoryColSelect.appendChild(option.cloneNode(true)); // X軸に追加
                dataColSelect.appendChild(option.cloneNode(true)); // Y軸に追加
                groupColSelect.appendChild(option.cloneNode(true)); // グループ軸に追加
            });

            // 初期選択をリセット
            categoryColSelect.value = INDEX_COLUMN_NAME; // X軸のデフォルトをIndexに
            dataColSelect.value = ''; // Y軸は何も選択しない
            groupColSelect.value = ''; // グループ軸は何も選択しない
            enableMultiSelectCheckbox.checked = false; // 複数選択をオフに
        }

        /**
         * Y軸の選択を単一/複数で切り替える
         * @param {boolean} enable - trueの場合、複数選択を有効にする
         */
        function toggleYAxisMultiSelect(enable) {
            // 既存の選択肢を保持
            const currentlySelected = Array.from(dataColSelect.options)
                                            .filter(opt => opt.selected)
                                            .map(opt => opt.value);

            // 属性を切り替え
            if (enable) {
                dataColSelect.setAttribute('multiple', true);
                dataColSelect.setAttribute('size', '6');
                dataColSelect.classList.add('multi-select');
                multiSelectTip.classList.remove('hidden');
                // 複数選択の場合、選択が解除されないよう、一旦全ての選択肢を解除
                Array.from(dataColSelect.options).forEach(opt => opt.selected = false);
            } else {
                dataColSelect.removeAttribute('multiple');
                dataColSelect.removeAttribute('size');
                dataColSelect.classList.remove('multi-select');
                multiSelectTip.classList.add('hidden');
            }

            // 以前選択されていたものを復元 (単一選択の場合は最初のものだけ)
            if (enable) {
                currentlySelected.forEach(val => {
                    const opt = dataColSelect.querySelector(`option[value="${val}"]`);
                    if (opt) opt.selected = true;
                });
            } else if (currentlySelected.length > 0) {
                dataColSelect.value = currentlySelected[0];
            } else {
                dataColSelect.value = '';
            }

            checkInputs();
        }

        /**
         * グラフタイプに基づいてUI表示を切り替える
         */
        function updateUIBasedOnChartType() {
            const chartType = chartTypeSelect.value;
            
            // 全ての選択グループを非表示に
            categorySelectGroup.classList.add('hidden');
            groupSelectGroup.classList.add('hidden'); // グループ列を非表示
            dataSelectGroup.classList.add('hidden');
            multiSelectToggle.classList.add('hidden');
            
            // 複数選択を強制的に無効化し、単一選択のドロップダウンに戻す
            enableMultiSelectCheckbox.checked = false;
            toggleYAxisMultiSelect(false); 

            // ラベルのデフォルト値を設定 (パレート図などで変更されたものをリセット)
            categorySelectGroup.querySelector('label').textContent = 'X軸 (カテゴリ/時系列)';
            groupSelectGroup.querySelector('label').textContent = 'グループ列 (層別 - 任意)';
            const yAxisLabel = dataSelectGroup.querySelector('label');


            switch (chartType) {
                case CHART_TYPE.BAR:
                    // 棒グラフ（数値）: X軸(任意, デフォルトIndex)、Y軸(単一数値)
                    categorySelectGroup.classList.remove('hidden');
                    dataSelectGroup.classList.remove('hidden');
                    yAxisLabel.textContent = 'Y軸 (数値 - 必須)';
                    break;
                case CHART_TYPE.LINE:
                    // 折れ線グラフ: X軸(任意, デフォルトIndex)、Y軸(単一/複数切替)
                    categoryColSelect.value = categoryColSelect.value === '' ? INDEX_COLUMN_NAME : categoryColSelect.value;
                    categorySelectGroup.classList.remove('hidden');
                    dataSelectGroup.classList.remove('hidden');
                    yAxisLabel.textContent = 'Y軸 (数値 - 必須)';
                    multiSelectToggle.classList.remove('hidden'); // 複数選択の切り替えを表示
                    break;
                case CHART_TYPE.SCATTER:
                    // 散布図: X軸(必須)、Y軸(必須) + グループ化 (任意)
                    categorySelectGroup.classList.remove('hidden');
                    dataSelectGroup.classList.remove('hidden');
                    groupSelectGroup.classList.remove('hidden'); // グループ列を表示
                    yAxisLabel.textContent = 'Y軸 (数値 - 必須)';
                    break;
                case CHART_TYPE.HISTOGRAM:
                    // ヒストグラム: X軸(任意, デフォルトIndex)、Y軸(データ値必須) + グループ化 (任意)
                    //categorySelectGroup.classList.remove('hidden');
                    dataSelectGroup.classList.remove('hidden');
                    groupSelectGroup.classList.remove('hidden'); // グループ列を表示
                    yAxisLabel.textContent = 'データ値 (数値 - 必須)';
                    break;
                case CHART_TYPE.BOX:
                    // 箱ひげ図: X軸は不要。データ値(必須) + グループ化(任意)
                    // categorySelectGroup は hidden のまま
                    dataSelectGroup.classList.remove('hidden');
                    groupSelectGroup.classList.remove('hidden'); // グループ列を表示
                    
                    // ラベルを設定
                    yAxisLabel.textContent = 'データ値 (数値 - 必須)';
                    groupSelectGroup.querySelector('label').textContent = 'グループ列 (層別 - 任意)';
                    break;
                case CHART_TYPE.PARETO:
                    // パレート図: X軸(カテゴリ必須)、Y軸(数値必須)
                    categorySelectGroup.classList.remove('hidden');
                    dataSelectGroup.classList.remove('hidden'); // Y軸も表示
                    // X軸ラベルを「必須」に変更
                    categorySelectGroup.querySelector('label').textContent = 'X軸 (カテゴリ - 必須)';
                    yAxisLabel.textContent = 'Y軸 (数値, 合計対象 - 必須)';
                    break;
                case CHART_TYPE.XRS_CONTROL:
                    // X-Rs管理図: Y軸(データ値必須)
                    dataSelectGroup.classList.remove('hidden');
                    yAxisLabel.textContent = 'データ列 (数値 - 必須)';
                    break;
                default:
                    // X軸ラベルをデフォルトに戻す
                    categorySelectGroup.querySelector('label').textContent = 'X軸 (カテゴリ/時系列)';
                    break;
            }

            checkInputs();
        }

        /**
         * グラフ作成ボタンの有効/無効をチェックする
         */
        function checkInputs() {
            const chartType = chartTypeSelect.value;
            const selectedYCols = getSelectedYAxisValues();
            let isValid = false;

            if (rawData.length === 0 || chartType === 'none') {
                generateChartBtn.disabled = true;
                return;
            }

            const xCol = categoryColSelect.value;

            switch (chartType) {
                case CHART_TYPE.BAR:
                    // 棒グラフ: Y軸(単一)が必須
                    isValid = selectedYCols.length === 1;
                    break;
                case CHART_TYPE.LINE:
                    // 折れ線グラフ: Y軸(複数可)が最低1つ必須
                    isValid = selectedYCols.length >= 1;
                    break;
                case CHART_TYPE.SCATTER:
                    // 散布図: X軸、Y軸両方必須 (IndexはX軸に使えない)
                    isValid = !!xCol && xCol !== INDEX_COLUMN_NAME && selectedYCols.length === 1;
                    break;
                case CHART_TYPE.HISTOGRAM:
                    // ヒストグラム: Y軸(単一)が必須
                    isValid = selectedYCols.length === 1;
                    break;
                case CHART_TYPE.BOX:
                    // 箱ひげ図: データ値(Y軸)のみ必須
                    isValid = selectedYCols.length === 1;
                    break;
                case CHART_TYPE.PARETO:
                    // パレート図: X軸(カテゴリ必須) and Y軸(単一必須) (Indexは不可)
                    isValid = !!xCol && xCol !== INDEX_COLUMN_NAME && selectedYCols.length === 1;
                    break;
                case CHART_TYPE.XRS_CONTROL:
                    // X-Rs管理図: Y軸(単一)が必須
                    isValid = selectedYCols.length === 1;
                    break;
                default:
                    isValid = false;
            }

            generateChartBtn.disabled = !isValid;
        }

        /**
         * データプレビューテーブルを更新する
         * @param {Array<Object>} data - データ行
         * @param {Array<string>} headers - ヘッダー名
         */
        function updateDataPreview(data, headers) {
            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-gray-200';
            
            // ヘッダー行
            const thead = table.createTHead();
            const headerRow = thead.insertRow();
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                th.className = 'px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-gray-50 sticky top-0';
                headerRow.appendChild(th);
            });

            // データ行
            const tbody = table.createTBody();
            data.slice(0, 100).forEach(row => { // 最大100行まで表示
                const tr = tbody.insertRow();
                headers.forEach(header => {
                    const td = tr.insertCell();
                    // undefinedの場合は空文字列を表示
                    td.textContent = row[header] === undefined ? '' : String(row[header]);
                    td.className = 'px-4 py-2 whitespace-nowrap text-sm text-gray-900 border-b border-gray-100';
                });
            });

            dataPreviewDiv.innerHTML = '';
            dataPreviewDiv.appendChild(table);
        }
        
        /**
         * グラフをPNGとしてダウンロードする
         */
        function handleDownload() {
            // Plotly.jsのダウンロード機能を使用
            Plotly.downloadImage('plot', {
                format: 'png',
                filename: 'chart_download',
                height: 600,
                width: 900
            }).catch(error => {
                console.error("ダウンロードエラー:", error);
                displayMessage('画像のダウンロード中にエラーが発生しました。', true);
            });
        }

        /**
         * グラフを生成する
         * @param {string} chartType - グラフタイプ
         * @param {string} categoryCol - X軸の列名 (箱ひげ図では無視される)
         * @param {Array<string>} dataCols - Y軸の列名の配列 (単一選択でも要素数1の配列)
         * @param {string} groupCol - グループ化に使用する列名 (空文字の場合はグループ化しない)
         */
        async function generateChart(chartType, categoryCol, dataCols, groupCol) {
            clearMessage();
            downloadChartBtn.disabled = true;
            
            if (rawData.length === 0 || dataCols.length === 0 && chartType !== CHART_TYPE.PARETO) {
                displayMessage('データがロードされていないか、Y軸が選択されていません。', true);
                return;
            }

            const primaryDataCol = dataCols[0]; // 単一選択の場合や、最初に処理するY軸

            // データ処理: 空のセルを除去し、数値に変換できるものは変換する
            const parsedData = rawData.map((row, index) => {
                const newRow = { 
                    [INDEX_COLUMN_NAME]: index + 1 // Index値を追加
                }; 
                for (const key in row) {
                    let value = row[key];
                    // 空白やnull/undefinedをスキップ
                    if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
                        newRow[key] = null;
                        continue;
                    }
                    // 数値に変換できるか試みる
                    const num = Number(value);
                    if (!isNaN(num) && isFinite(num)) {
                        newRow[key] = num;
                    } else {
                        newRow[key] = String(value); // 文字列として保持
                    }
                }
                return newRow;
            });
            
            // X軸のデータを決定 (BOX以外で使用)
            const xCol = categoryCol === INDEX_COLUMN_NAME || !categoryCol ? INDEX_COLUMN_NAME : categoryCol;
            const xTitle = xCol === INDEX_COLUMN_NAME ? 'データポイント Index' : xCol;

            let plotData = [];
            let layout = {};

            // グループ化ロジックの判定とヘルパー (SCATTER, HISTOGRAMで使用)
            const isGrouped = !!groupCol && dataCols.indexOf(groupCol) === -1; // groupColが選択されており、それがY軸データ列と重複していない

            
            /**
             * データをグループ化するヘルパー関数 (SCATTER, HISTOGRAM用)
             * BOXチャートでは、グループ化の有無で処理を明確に分けるため、このヘルパーは使用しない。
             * @param {Array<Object>} data - フィルタリング前のデータ
             * @param {string} groupKey - グループ化に使用するキー
             * @returns {Object<string, Array<Object>>} グループ化されたデータ
             */
            const getGroupedData = (data, groupKey) => {
                if (!isGrouped || !groupKey) {
                    return { '__DEFAULT__': data };
                }
                return data.reduce((acc, row) => {
                    const key = row[groupKey] !== null ? row[groupKey] : 'NULL_GROUP';
                    if (!acc[key]) {
                        acc[key] = [];
                    }
                    acc[key].push(row);
                    return acc;
                }, {});
            };

            try {
                switch (chartType) {
                    case CHART_TYPE.BAR:
                        // X軸とY軸の数値データをフィルタリング
                        const barFilteredData = parsedData.filter(row => row[xCol] !== null && typeof row[primaryDataCol] === 'number');

                        plotData = [{
                            x: barFilteredData.map(row => row[xCol]),
                            y: barFilteredData.map(row => row[primaryDataCol]),
                            type: 'bar',
                            name: primaryDataCol,
                            marker: { color: 'rgb(55, 83, 109)' }
                        }];
                        layout = {
                            title: `${primaryDataCol} の棒グラフ`,
                            height: 600,
                            xaxis: { 
                                title: xTitle, 
                                automargin: true,
                                type: xCol === INDEX_COLUMN_NAME ? 'linear' : 'category',
                                showgrid: false
                            },
                            yaxis: { title: primaryDataCol, automargin: true, rangemode: 'tozero' },
                            margin: { t: 40, b: 40, l: 40, r: 20 }
                        };
                        break;

                    case CHART_TYPE.LINE:
                        let colors = ['rgb(31, 119, 180)', 'rgb(255, 127, 14)', 'rgb(44, 160, 44)', 'rgb(214, 39, 40)', 'rgb(148, 103, 189)', 'rgb(140, 86, 75)'];
                        
                        // 選択されたY軸ごとにトレースを作成
                        plotData = dataCols.map((yCol, index) => {
                            const lineFilteredData = parsedData.filter(row => row[xCol] !== null && typeof row[yCol] === 'number');

                            return {
                                x: lineFilteredData.map(row => row[xCol]),
                                y: lineFilteredData.map(row => row[yCol]),
                                mode: 'lines', // マーカーを削除 (X-Rs管理図とパレート図以外)
                                type: 'scatter',
                                name: yCol,
                                line: { color: colors[index % colors.length] }
                            };
                        });
                        
                        const lineTitle = dataCols.length > 1 ? `${dataCols.join(', ')} の折れ線グラフ` : `${primaryDataCol} の折れ線グラフ`;
                        layout = {
                            title: lineTitle,
                            height: 600,
                            xaxis: { title: xTitle, automargin: true, showgrid: true },
                            yaxis: { title: '値', automargin: true },
                            margin: { t: 40, b: 40, l: 40, r: 20 },
                            legend: { orientation: 'h', y: -0.15, x: 0.5, xanchor: 'center' }
                        };
                        break;
                    
                    case CHART_TYPE.SCATTER:
                        // SCATTER: X軸、Y軸必須 + グループ化 (任意)
                        const scatterGroupedData = getGroupedData(parsedData, groupCol);
                        
                        for (const groupKey in scatterGroupedData) {
                            const groupData = scatterGroupedData[groupKey];
                            const scatterFilteredData = groupData.filter(row => typeof row[xCol] === 'number' && typeof row[primaryDataCol] === 'number');

                            plotData.push({
                                x: scatterFilteredData.map(row => row[xCol]),
                                y: scatterFilteredData.map(row => row[primaryDataCol]),
                                mode: 'markers',
                                type: 'scatter',
                                name: isGrouped ? `${groupCol}: ${groupKey}` : primaryDataCol,
                                marker: { size: 8, opacity: 0.6 }
                            });
                        }

                        const scatterTitle = `${primaryDataCol} vs ${xCol} の散布図` + (isGrouped ? ` (${groupCol}層別)` : '');
                        layout = {
                            title: scatterTitle,
                            height: 600,
                            xaxis: { title: xCol, automargin: true },
                            yaxis: { title: primaryDataCol, automargin: true },
                            margin: { t: 40, b: 40, l: 40, r: 20 },
                            legend: { orientation: 'h', y: -0.15, x: 0.5, xanchor: 'center' }
                        };
                        break;

                    case CHART_TYPE.HISTOGRAM:
                        // HISTOGRAM: Y軸必須 + グループ化 (任意)
                        const histGroupedData = getGroupedData(parsedData, groupCol);

                        for (const groupKey in histGroupedData) {
                            const groupData = histGroupedData[groupKey];
                            const histData = groupData.map(row => row[primaryDataCol]).filter(val => typeof val === 'number' && val !== null);
                            
                            plotData.push({
                                x: histData,
                                type: 'histogram',
                                name: isGrouped ? `${groupCol}: ${groupKey}` : primaryDataCol,
                                opacity: 0.7 // 重ねて表示するため
                            });
                        }
                        
                        layout = {
                            title: `${primaryDataCol} のヒストグラム` + (isGrouped ? ` (${groupCol}別)` : ''),
                            height: 600,
                            xaxis: { title: primaryDataCol, automargin: true },
                            yaxis: { title: '度数', automargin: true, rangemode: 'tozero' },
                            barmode: isGrouped ? 'overlay' : 'group', // 重ねて表示
                            bargap: 0.05,
                            margin: { t: 40, b: 40, l: 40, r: 20 },
                            legend: { orientation: 'h', y: -0.15, x: 0.5, xanchor: 'center' }
                        };
                        break;

                    case CHART_TYPE.BOX:
                        // BOX: データ値(必須) + グループ化(任意)
                        
                        // 必要な数値データのみをフィルタリング
                        const boxDataAll = parsedData.filter(row => typeof row[primaryDataCol] === 'number' && row[primaryDataCol] !== null);
                        
                        // グループ列が指定されているか確認
                        const boxGroupCol = groupColSelect.value;
                        const hasGrouping = !!boxGroupCol;

                        if (hasGrouping) {
                            // 1. 層別箱ひげ図: グループ列をX軸として使用
                            // 有効なグループキーを取得
                            const groupKeys = [...new Set(boxDataAll.map(row => row[boxGroupCol]).filter(v => v !== null && v !== undefined && v !== ''))];

                            plotData = groupKeys.map(groupKey => {
                                const groupData = boxDataAll.filter(row => row[boxGroupCol] === groupKey);
                                
                                return {
                                    x: groupData.map(() => groupKey), // X軸にはグループ名
                                    y: groupData.map(row => row[primaryDataCol]),
                                    type: 'box',
                                    name: groupKey,
                                    boxpoints: 'outliers'
                                };
                            });
                            
                            layout = {
                                title: `${primaryDataCol} の箱ひげ図 (${boxGroupCol}別)`,
                                height: 600,
                                xaxis: { title: boxGroupCol, automargin: true, showgrid: true, zeroline: false, type: 'category' },
                                yaxis: { title: primaryDataCol, automargin: true },
                                boxmode: 'group',
                                margin: { t: 40, b: 40, l: 40, r: 20 },
                                legend: { orientation: 'h', y: -0.15, x: 0.5, xanchor: 'center' }
                            };

                        } else {
                            // 2. 単一箱ひげ図: グループ化なし。X軸は非表示
                            const yValues = boxDataAll.map(row => row[primaryDataCol]);

                            plotData = [{
                                y: yValues, // Y値のみを渡す
                                type: 'box',
                                name: primaryDataCol,
                                boxpoints: 'all', // 全ての点を表示
                                marker: { color: 'rgb(44, 160, 44)' }
                            }];
                            
                            layout = {
                                title: `${primaryDataCol} の分布 (箱ひげ図)`,
                                height: 600,
                                // X軸は完全に非表示に設定
                                xaxis: { 
                                    showticklabels: false, // X軸のラベルを非表示
                                    showgrid: false,
                                    zeroline: false
                                },
                                yaxis: { title: primaryDataCol, automargin: true },
                                margin: { t: 40, b: 40, l: 40, r: 20 }
                            };
                        }
                        break;

                    case CHART_TYPE.PARETO:
                        // パレート図：X軸(カテゴリ)とY軸(数値)の合計で集計
                        
                        // Y軸の数値列
                        // primaryDataColはdataCols[0]で取得済み

                        // データ集計 (合計値の計算)
                        const sums = {};
                        parsedData.forEach(row => {
                            let category = row[xCol];
                            let value = row[primaryDataCol]; // Y軸の数値
                            
                            // カテゴリが有効かつY軸が数値である行のみを対象
                            if (category !== null && category !== undefined && category !== "" && 
                                typeof value === 'number' && !isNaN(value)) {
                                
                                if (typeof category === 'number') {
                                    category = String(category);
                                }
                                sums[category] = (sums[category] || 0) + value;
                            }
                        });

                        // 集計結果を配列に変換し、降順でソート
                        let aggregatedData = Object.entries(sums).map(([category, sum]) => ({
                            category,
                            sum
                        }));
                        aggregatedData.sort((a, b) => b.sum - a.sum);

                        // 累積合計と累積比率の計算
                        let totalSum = aggregatedData.reduce((sum, item) => sum + item.sum, 0);
                        let cumulativeSum = 0;
                        aggregatedData.forEach(item => {
                            cumulativeSum += item.sum;
                            item.cumulativeRatio = cumulativeSum / totalSum;
                        });

                        // Plotlyのデータとレイアウトを準備
                        const categories = aggregatedData.map(item => item.category);
                        const categorySums = aggregatedData.map(item => item.sum);
                        const cumulativeRatios = aggregatedData.map(item => item.cumulativeRatio);

                        const barTrace = {
                            x: categories,
                            y: categorySums,
                            type: 'bar',
                            name: `${primaryDataCol} 合計`,
                            marker: { color: 'rgb(55, 83, 109)' },
                            yaxis: 'y1'
                        };

                        const lineTrace = {
                            x: categories,
                            y: cumulativeRatios,
                            mode: 'lines+markers', // パレート図の累積比率はマーカーを残す
                            type: 'scatter',
                            name: '累積比率',
                            line: { color: 'rgb(214, 39, 40)', shape: 'spline' },
                            yaxis: 'y2'
                        };

                        plotData = [barTrace, lineTrace];
                        
                        layout = {
                            title: `${xCol} のパレート図 (${primaryDataCol} の合計)`,
                            height: 600,
                            xaxis: {
                                title: xCol,
                                automargin: true,
                                type: 'category',
                                categoryorder: 'array',
                                categoryarray: categories
                            },
                            yaxis: {
                                title: `${primaryDataCol} の合計`,
                                automargin: true,
                                side: 'left',
                                rangemode: 'tozero',
                                hoverformat: ',.2f'
                            },
                            yaxis2: {
                                title: '累積比率',
                                automargin: true,
                                side: 'right',
                                overlaying: 'y',
                                range: [0, 1],
                                tickformat: '.0%',
                                showgrid: false
                            },
                            margin: { t: 40, b: 40, l: 40, r: 20 },
                            legend: { orientation: 'h', y: -0.15, x: 0.5, xanchor: 'center' }
                        };
                        break;
                    
                    case CHART_TYPE.XRS_CONTROL:
                        // X-Rs管理図 (サブグループサイズ n=1)
                        
                        const controlChartData = parsedData.map(row => row[primaryDataCol]).filter(val => typeof val === 'number' && val !== null);
                        if (controlChartData.length === 0) {
                            displayMessage('X-Rs管理図には数値データ列が必要です。', true);
                            return;
                        }

                        // 定数 (n=2の近似)
                        const m = controlChartData.length; // データポイント数
                        const d2_n2 = 1.128; // n=2 の d2
                        const D4_n2 = 3.267; // n=2 の D4
                        const D3_n2 = 0;     // n=2 の D3 (n<7のため)

                        const xValues = controlChartData;
                        const points = Array.from({ length: m }, (_, i) => i + 1);

                        // 移動範囲 (Rs) の計算
                        const rsValues = [];
                        for (let i = 1; i < m; i++) {
                            rsValues.push(Math.abs(xValues[i] - xValues[i-1]));
                        }
                        const rsPoints = Array.from({ length: m - 1 }, (_, i) => i + 2); // 2番目以降のポイント

                        // 管理限界線
                        const xBar = xValues.reduce((sum, val) => sum + val, 0) / m;
                        const rsBar = rsValues.length > 0 ? rsValues.reduce((sum, val) => sum + val, 0) / rsValues.length : 0;
                        
                        const xucl = xBar + 3 * (rsBar / d2_n2);
                        const xcl = xBar;
                        const xlcl = xBar - 3 * (rsBar / d2_n2);
                        const rsUcl = D4_n2 * rsBar;
                        const rsCl = rsBar;
                        const rsLcl = D3_n2 * rsBar;

                        // X-bar 管理図のトレース
                        const xTrace = {
                            x: points, y: xValues, mode: 'line', name: 'X (値)', marker: { color: 'rgb(31, 119, 180)' }, line: { width: 1 }, yaxis: 'y1'
                        };
                        const xuclTrace = {
                            x: points, y: Array(m).fill(xucl), mode: 'lines', name: 'UCL (X)', line: { color: 'red', dash: 'dash', width: 1 }, yaxis: 'y1'
                        };
                        const xclTrace = {
                            x: points, y: Array(m).fill(xcl), mode: 'lines', name: 'CL (X)', line: { color: 'black', width: 1 }, yaxis: 'y1'
                        };
                        const xlclTrace = {
                            x: points, y: Array(m).fill(xlcl < 0 ? 0 : xlcl), mode: 'lines', name: 'LCL (X)', line: { color: 'red', dash: 'dash', width: 1 }, yaxis: 'y1'
                        };

                        // Rs 管理図のトレース
                        const rsTrace = {
                            x: rsPoints, y: rsValues, mode: 'lines', name: 'Rs (移動範囲)', marker: { color: 'rgb(255, 127, 14)' }, line: { width: 1 }, yaxis: 'y2'
                        };
                        const rsUclTrace = {
                            x: rsPoints, y: Array(m - 1).fill(rsUcl), mode: 'lines', name: 'UCL (Rs)', line: { color: 'red', dash: 'dash', width: 1 }, yaxis: 'y2'
                        };
                        const rsClTrace = {
                            x: rsPoints, y: Array(m - 1).fill(rsCl), mode: 'lines', name: 'CL (Rs)', line: { color: 'black', width: 1 }, yaxis: 'y2'
                        };
                        const rsLclTrace = {
                            x: rsPoints, y: Array(m - 1).fill(rsLcl < 0 ? 0 : rsLcl), mode: 'lines', name: 'LCL (Rs)', line: { color: 'red', dash: 'dash', width: 1 }, yaxis: 'y2'
                        };

                        plotData = [xTrace, xuclTrace, xclTrace, xlclTrace, rsTrace, rsUclTrace, rsClTrace, rsLclTrace];

                        layout = {
                            title: `${primaryDataCol} の X-Rs 管理図`,
                            height: 800,
                            grid: {
                                rows: 2, columns: 1, subplots: [['xy'], ['xy2']], roworder: 'top to bottom', ygap: 0.1
                            },
                            xaxis: { 
                                title: 'Index', automargin: true, showgrid: true, zeroline: false, rangemode: 'tozero'
                            },
                            yaxis: { 
                                title: 'X (値)', domain: [0.55, 1.0], automargin: true, hoverformat: '.3f'
                            },
                            yaxis2: { 
                                title: 'Rs (移動範囲)', domain: [0.0, 0.45], automargin: true, rangemode: 'tozero', hoverformat: '.3f'
                            },
                            margin: { t: 40, b: 40, l: 40, r: 20 },
                            hovermode: 'x unified',
                            legend: { orientation: 'h', y: -0.15, x: 0.5, xanchor: 'center' }
                        };

                        break;

                    default:
                        displayMessage('グラフタイプを選択してください。', true);
                        return;
                }

                // グラフ描画
                await Plotly.newPlot(chartContainer, plotData, layout, { 
                    responsive: true, 
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d', 'sendDataToCloud', 'hoverClosestCartesian', 'hoverCompareCartesian'],
                    displaylogo: false
                });

                downloadChartBtn.disabled = false;

            } catch (error) {
                console.error("グラフ描画エラー:", error);
                displayMessage('グラフの描画中にエラーが発生しました。データを確認してください。', true);
                downloadChartBtn.disabled = true;
            }
        }
    </script>
</body>
</html>
